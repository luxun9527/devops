input {
  file {
    path => "/usr/share/logstash/logs/*/*.log"
    start_position => "beginning"
    sincedb_path => "/usr/share/logstash/data/sincedb"
    mode => "tail"
  }
}

filter {
  # 提取文件名
  grok {
    match => { "path" => ".*\/(?<filename>[^\/.]+)\..*" }  # 优化正则表达式，确保文件名提取准确
  }

  # 尝试解析 JSON 格式
  json {
    source => "message"
    remove_field => ["message"]
    remove_tag => ["_jsonparsefailure", "_grokparsefailure"]
  }

  # JSON 解析失败的处理
  if "_jsonparsefailure" in [tags] {
    mutate {
      remove_tag => ["_jsonparsefailure"]
    }
  }

  # 使用 ruby 过滤器（含互斥锁）
  ruby {
    code => '
      # 初始化全局锁和文件名 Map
      $filename_map ||= {}
      $mutex ||= Mutex.new

      filename = event.get("filename")
      logger.info("Processing filename: #{filename}")

      # 使用互斥锁保护共享资源
      $mutex.synchronize do
        # 如果文件名未处理过，则执行创建逻辑
        if !$filename_map.key?(filename)
          logger.info("Attempting to create index for: #{filename}")

          # 创建索引和别名
          index_url = "http://elasticsearch:9200/logs_#{filename}-000001"
          index_payload = {
            "aliases" => {
              "logs_#{filename}" => {
                "is_write_index" => true
              }
            }
          }.to_json

          uri = URI(index_url)
          http = Net::HTTP.new(uri.host, uri.port)
          request = Net::HTTP::Put.new(uri.path, {
            "Content-Type" => "application/json",
            "Authorization" => "Basic ZWxhc3RpYzoxMjM0NTY="
          })
          request.body = index_payload

          response = http.request(request)

          if response.code == "200"
            logger.info("Index created: logs_#{filename}-000001")
          else
            logger.error("Failed to create index: #{response.body}")
            next  # 索引创建失败，直接跳过后续操作
          end

          # 创建模板
          template_url = "http://elasticsearch:9200/_index_template/logs_#{filename}_template"
          template_payload = {
            "index_patterns" => ["logs_#{filename}-*"],
            "template" => {
              "settings" => {
                "number_of_shards" => 1,
                "number_of_replicas" => 1,
                "index.lifecycle.name" => "logs_policy",
                "index.lifecycle.rollover_alias" => "logs_#{filename}"
              }
            }
          }.to_json

          uri = URI(template_url)
          http = Net::HTTP.new(uri.host, uri.port)
          request = Net::HTTP::Put.new(uri.path, {
            "Content-Type" => "application/json",
            "Authorization" => "Basic ZWxhc3RpYzoxMjM0NTY="
          })
          request.body = template_payload

          response = http.request(request)

          if response.code == "200"
            logger.info("Template created: logs_#{filename}_template")
            $filename_map[filename] = true  # 标记为已处理（仅在成功时）
          else
            logger.error("Failed to create template: #{response.body}")
          end

        else
          logger.debug("Skipping processed filename: #{filename}")
        end
      end
    '
  }
}

output {
  elasticsearch {
    hosts => ["http://elasticsearch:9200"]
    index => "logs_%{[filename]}"
    user => "elastic"
    password => "123456"
  }

  stdout {
    codec => rubydebug
  }
}