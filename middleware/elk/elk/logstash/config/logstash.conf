input {
  file {
    path => "/usr/share/logstash/logs/*/*.log"
    start_position => "beginning"
    sincedb_path => "/usr/share/logstash/data/sincedb"
    mode => "tail"
  }
}

filter {
  # 提取文件名
  grok {
    match => { "path" => ".*\/(?<filename>[^\.]+)\..*" }
  }

  # 尝试解析 JSON 格式
  json {
    source => "message"
    remove_field => ["message"]  # 删除原始的 message 字段
    remove_tag => ["_jsonparsefailure", "_grokparsefailure"]  # 删除解析失败的标签
  }

  # 如果 JSON 解析失败，将原始日志保存到 message 字段，并删除多余的双引号
  if "_jsonparsefailure" in [tags] {
    mutate {
      remove_tag => ["_jsonparsefailure"]  # 删除 _jsonparsefailure 标签
    }
  }

  # 使用 ruby 过滤器检查文件名是否已存在，并执行创建操作
 ruby {
   code => '
     # 初始化全局变量：两个 map 和两个锁
     $index_map ||= {}
     $template_map ||= {}
     $index_mutex ||= Mutex.new
     $template_mutex ||= Mutex.new

     # 获取当前文件名
     filename = event.get("filename")

     # 处理索引创建
     $index_mutex.synchronize do
       if !$index_map.key?(filename)
         logger.debug("Attempting to create index for filename: #{filename}")

         # 创建索引和别名的 URL 和请求体
         index_url = "http://elasticsearch:9200/logs_#{filename}-000001"
         index_payload = {
           "aliases" => {
             "logs_#{filename}" => {
               "is_write_index" => true
             }
           }
         }.to_json

         # 创建 URI 对象
         uri = URI(index_url)

         # 创建 HTTP 对象
         http = Net::HTTP.new(uri.host, uri.port)

         # 创建 PUT 请求
         request = Net::HTTP::Put.new(uri.path, {
           "Content-Type" => "application/json",
           "Authorization" => "Basic ZWxhc3RpYzoxMjM0NTY="
         })
         request.body = index_payload

         # 发送请求
         response = http.request(request)

         # 打印日志
         if response.code == "200"
           logger.info("Successfully created index for filename: #{filename}")
         else
           logger.error("Failed to create index for filename: #{filename}, error: #{response.body}")
         end
         $index_map[filename] = true  # 标记索引已经创建

       else
         logger.debug("Index already created for filename: #{filename}")
       end
     end

     # 处理模板创建
     $template_mutex.synchronize do
       if !$template_map.key?(filename)
         logger.debug("Attempting to create template for filename: #{filename}")

         # 创建模板的 URL 和请求体
         template_url = "http://elasticsearch:9200/_index_template/logs_#{filename}_template"
         template_payload = {
           "index_patterns" => ["logs_#{filename}-*"],
           "template" => {
             "settings" => {
               "number_of_shards" => 1,
               "number_of_replicas" => 1,
               "index.lifecycle.name" => "logs_policy",
               "index.lifecycle.rollover_alias" => "logs_#{filename}"
             }
           }
         }.to_json

         # 创建 URI 对象
         uri = URI(template_url)

         # 创建 HTTP 对象
         http = Net::HTTP.new(uri.host, uri.port)

         # 创建 PUT 请求
         request = Net::HTTP::Put.new(uri.path, {
           "Content-Type" => "application/json",
           "Authorization" => "Basic ZWxhc3RpYzoxMjM0NTY="
         })
         request.body = template_payload

         # 发送请求
         response = http.request(request)

         # 打印日志
         if response.code == "200"
           logger.info("Successfully created template for filename: #{filename}")
           $template_map[filename] = true  # 标记模板为已创建
         else
           logger.error("Failed to create template for filename: #{filename}, error: #{response.body}")
         end
       else
         logger.debug("Template already created for filename: #{filename}")
       end
     end
   '
 }
}

output {
  # 输出到 Elasticsearch
  elasticsearch {
    hosts => ["http://elasticsearch:9200"]
    index => "logs_%{[filename]}"
    user => "elastic"
    password => "123456"
  }

  # 输出到控制台（用于调试）
  stdout {
    codec => rubydebug
  }
}